import tkinter as tk
from tkinter import ttk

class GateDraggable(tk.Label):
    def __init__(self, parent, gate_type):
        super().__init__(parent, text=gate_type, relief=tk.RAISED, width=10, height=2)
        self.gate_type = gate_type
        self.bind("<Button-1>", self.on_drag_start)
        self.bind("<B1-Motion>", self.on_drag_motion)
        self.bind("<ButtonRelease-1>", self.on_drag_release)

    def on_drag_start(self, event):
        self.start_x = event.x
        self.start_y = event.y

    def on_drag_motion(self, event):
        x = self.winfo_x() - self.start_x + event.x
        y = self.winfo_y() - self.start_y + event.y
        self.place(x=x, y=y)

    def on_drag_release(self, event):
        x = self.winfo_x() - self.start_x + event.x
        y = self.winfo_y() - self.start_y + event.y

        if self.master.winfo_containing(x, y) != self.master.left_frame:
            # 왼쪽 공간에 놓지 않은 경우에만 게이트를 생성
            self.master.create_gate_instance(self.gate_type, x, y)
        else:
            # 왼쪽 공간에 놓은 경우, 게이트 모양으로 표현
            self.place_forget()
            gate_shape = GateDraggable(self.master.left_frame, self.gate_type)
            gate_shape.place(x=x, y=y)

class CircuitDesigner(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Circuit Designer")

        self.left_frame = ttk.Frame(self, width=300, height=600)
        self.left_frame.pack(side=tk.LEFT, fill=tk.BOTH, padx=10, pady=10)

        self.right_frame = ttk.Frame(self, width=400, height=600, relief=tk.SUNKEN, borderwidth=2)
        self.right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, padx=10, pady=10)

        self.gate_instances = []

        self.create_gates()

    def create_gates(self):
        gates = ["AND", "OR", "NOT", "NOR", "NAND"]
        row, col = 0, 0

        for gate_type in gates:
            gate = GateDraggable(self.right_frame, gate_type)
            gate.grid(row=row, column=col, padx=10, pady=10)
            col += 1

            if col > 1:
                col = 0
                row += 1

    def create_gate_instance(self, gate_type, x, y):
        gate_instance = GateDraggable(self, gate_type)
        gate_instance.place(x=x, y=y)
        self.gate_instances.append(gate_instance)

    def create_gate_shape(self, gate_type, x, y):
        gate_shape = tk.Label(self.left_frame, text=gate_type, relief=tk.RAISED, width=10, height=2)
        gate_shape.place(x=x, y=y)

if __name__ == "__main__":
    app = CircuitDesigner()
    app.mainloop()
    
 
#
def generate_truth_table(gates):
    inputs = []
    outputs = []
    gate_names = []

    # Get input names
    for gate in gates:
        if gate.name == "Start":
            inputs.append(gate.output)
            gate_names.append(gate.name)

    # Generate truth table
    for i in range(2 ** len(inputs)):
        input_values = format(i, '0{}b'.format(len(inputs)))
        for j, gate in enumerate(gates):
            if gate.name == "Start":
                gate.set_output(int(input_values[j]))

        output_values = [gate.calculate_output() for gate in gates if gate.name != "Start"]
        inputs_str = ', '.join(str(val) for val in input_values)
        outputs_str = ', '.join(str(val) for val in output_values)
        print("Inputs: [{}], Outputs: [{}]".format(inputs_str, outputs_str))
        outputs.append(output_values)

    # Print truth table header
    inputs_str = ', '.join(gate_names)
    outputs_str = ', '.join(gate.name for gate in gates if gate.name != "Start")
    print("\nTruth Table:\nInputs: [{}], Outputs: [{}]".format(inputs_str, outputs_str))

    # Print truth table values
    for i in range(len(outputs)):
        inputs_values_str = ', '.join(str(val) for val in inputs[i])
        outputs_values_str = ', '.join(str(val) for val in outputs[i])
        print("Inputs: [{}], Outputs: [{}]".format(inputs_values_str, outputs_values_str))
        
        
        #진리표 기능 추가
        import tkinter as tk

def show_truth_table():
    truth_table_window = tk.Toplevel()
    truth_table_window.title("진리표")
    
    # 입력 변수 이름을 가져오기
    var_names = var_entry.get().split(',')
    num_vars = len(var_names)
    
    # 출력 게이트 종류 설정
    gate_names = ['and', 'not', 'or', 'nand', 'nor', 'xor']
    
    # 진리표 헤더 생성
    for i, var_name in enumerate(var_names):
        label = tk.Label(truth_table_window, text=var_name)
        label.grid(row=0, column=i)
    for i, gate_name in enumerate(gate_names):
        label = tk.Label(truth_table_window, text=gate_name)
        label.grid(row=0, column=num_vars + i)
    
    # 진리표 데이터 생성
    for i in range(2**num_vars):
        input_values = []
        for j in range(num_vars):
            input_values.append((i // 2**j) % 2)
        
        for j, input_value in enumerate(input_values):
            label = tk.Label(truth_table_window, text=str(input_value))
            label.grid(row=i+1, column=j)
        
        for j, gate_name in enumerate(gate_names):
            output_value = calculate_output(gate_name, input_values)
            label = tk.Label(truth_table_window, text=str(output_value))
            label.grid(row=i+1, column=num_vars + j)
    
def calculate_output(gate_name, input_values):
    if gate_name == 'and':
        return int(all(input_values))
    elif gate_name == 'not':
        return int(not input_values[0])
    elif gate_name == 'or':
        return int(any(input_values))
    elif gate_name == 'nand':
        return int(not all(input_values))
    elif gate_name == 'nor':
        return int(not any(input_values))
    elif gate_name == 'xor':
        return int(sum(input_values) % 2)
    else:
        return None
    
# 메인 윈도우 생성
root = tk.Tk()

# 변수 입력을 받을 엔트리 위젯 생성
var_entry_label = tk.Label(root, text="변수 입력 (쉼표로 구분):")
var_entry_label.pack()
var_entry = tk.Entry(root)
var_entry.pack()

# 진리표 버튼 생성
truth_table_button = tk.Button(root, text="진리표 보기", command=show_truth_table)
truth_table_button.pack()

# 프로그램 실행
root.mainloop()

