from asyncio.windows_events import *
from asyncio.windows_events import NULL
from tkinter import *

global win
win = Tk()

win.title("Test")
win.option_add("*Fonts", "맑은고딕 25")
win.geometry("1280x800")

global canv
canv = Canvas(win, width = 1280, height = 800, background = 'white')
canv.pack(padx = 0, pady = 0)

global match_N
match_N = []        #P, Q등 input 정해지면 ('P', '1') 형태로 넣기



def eval_exp(expression):

    global match_N
    for i in match_N:
        expression = expression.replace(i[0], i[1])

    result = eval(expression)

    return result



def Draw_gate(Type, x, y):
    shapes = []
    if(Type == 'And'):
        #AND gate ========================================================================================
        A_x = x - 15
        A_y = y - 18

        shapes.append(canv.create_polygon(A_x + 30, A_y + 36, A_x, A_y + 36, A_x, A_y, A_x + 30, A_y, fill = "white", outline = 'black', width = 3))
        shapes.append(canv.create_line(A_x + 30, A_y + 36, A_x + 30, A_y, fill = "white", width = 3))
        shapes.append(canv.create_line(A_x + 30.3, A_y, A_x + 57, A_y + 18, A_x + 30.3, A_y + 36, fill = "black", width = 3, smooth = True))

    elif(Type == "Or"):
        #OR gate============================================================================================
        O_x = x - 25
        O_y = y - 18

        shapes.append(canv.create_polygon(O_x + 5, O_y + 2, O_x + 32, O_y + 2, O_x + 32, O_y + 34, O_x + 5, O_y +34, fill = 'white'))
        shapes.append(canv.create_line(O_x, O_y,       O_x + 40, O_y + 2,     O_x + 50, O_y + 18, fill = "black", width = 3, smooth = True))
        shapes.append(canv.create_line(O_x, O_y + 36,  O_x + 40, O_y + 34,    O_x + 50, O_y + 18, fill = "black", width = 3, smooth = True))
        shapes.append(canv.create_line(O_x, O_y,       O_x + 10, O_y + 20,    O_x, O_y + 36, fill = "black", width = 3, smooth = True))

    elif(Type == "Ex_or"):
            #Ex_OR gate============================================================================================
        EO_x = x - 25
        EO_y = y - 18

        shapes.append(canv.create_polygon(EO_x + 5, EO_y + 2, EO_x + 32, EO_y + 2, EO_x + 32, EO_y + 34, EO_x + 5, EO_y +34, fill = 'white'))
        shapes.append(canv.create_line(EO_x, EO_y,       EO_x + 40, EO_y + 2,     EO_x + 50, EO_y + 18, fill = "black", width = 3, smooth = True))
        shapes.append(canv.create_line(EO_x, EO_y + 36,  EO_x + 40, EO_y + 34,    EO_x + 50, EO_y + 18, fill = "black", width = 3, smooth = True))
        shapes.append(canv.create_line(EO_x, EO_y,       EO_x + 10, EO_y + 20,    EO_x, EO_y + 36, fill = "black", width = 3, smooth = True))
        shapes.append(canv.create_line(EO_x - 8, EO_y,       EO_x + 2, EO_y + 20,    EO_x - 8, EO_y + 36, fill = "black", width = 2.5, smooth = True))

    elif(Type == "Not"):
       #NOT gate============================================================================================

        N_x = x - 10
        N_y = y - 9

        shapes.append(canv.create_polygon(N_x, N_y,       N_x, N_y + 34,     N_x + 30, N_y + 18, N_x, N_y, fill = "white", outline = 'black', width = 3))
        shapes.append(canv.create_oval(N_x + 30, N_y + 13, N_x + 40, N_y + 23, width = 2))


    elif(Type == "Nor"):
        #NOR gate============================================================================================
        
        NO_x = x - 25
        NO_y = y - 18

        shapes.append(canv.create_polygon(NO_x + 5, NO_y + 2, NO_x + 32, NO_y + 2, NO_x + 32, NO_y + 34, NO_x + 5, NO_y +34, fill = 'white'))
        shapes.append(canv.create_line(NO_x, NO_y,       NO_x + 40, NO_y + 2,     NO_x + 50, NO_y + 18, fill = "black", width = 3, smooth = True))
        shapes.append(canv.create_line(NO_x, NO_y + 36,  NO_x + 40, NO_y + 34,    NO_x + 50, NO_y + 18, fill = "black", width = 3, smooth = True))
        shapes.append(canv.create_line(NO_x, NO_y,       NO_x + 10, NO_y + 20,    NO_x, NO_y + 36, fill = "black", width = 3, smooth = True))
        shapes.append(canv.create_oval(NO_x + 50, NO_y + 13, NO_x + 60, NO_y + 23, width = 2))

    elif(Type == "Nand"):

        #NAND gate ========================================================================================
        NA_x = x - 15
        NA_y = y - 18

        shapes.append(canv.create_polygon(NA_x + 30, NA_y + 36, NA_x, NA_y + 36, NA_x, NA_y, NA_x + 30, NA_y, fill = "white", outline = 'black', width = 3))
        shapes.append(canv.create_line(NA_x + 30, NA_y + 36, NA_x + 30, NA_y, fill = "white", width = 3))
        shapes.append(canv.create_line(NA_x + 30.3, NA_y, NA_x + 57, NA_y + 18, NA_x + 30.3, NA_y + 36, fill = "black", width = 3, smooth = True))
        shapes.append(canv.create_oval(NA_x + 44, NA_y + 13, NA_x + 54, NA_y + 23, width = 2))

    # Start End

    return shapes
#==============================================================================================


class Point:            #점의 위치
    px = float()
    py = float()
    res = str()
    val = int()
    b = int()
    F_S = -1    #input 2개인 gate - 몇번째인지 / 1개인 gate 구분 위함

    def __init__(self, x, y):
        self.px = x
        self.py = y
        self.res = None
        self.val = None
        self.b = canv.create_oval(self.px - 4, self.py - 4, self.px + 4, self.py + 4, fill="black")

    def setPoint(self, x, y):
        self.px = x
        self.py = y
        canv.delete(self.b)
        self.b = canv.create_oval(self.px - 4, self.py - 4, self.px + 4, self.py + 4, fill="black")

    def setRes(self, val):
        self.res = val
        if self.gate:
            if(self.F_S == 0):
                self.gate.Input0 = val
            elif(self.F_S == 1):
                self.gate.Input1 = val
            elif(self.F_S == 2):
                self.gate.Input2 = val
        
    def set_gate(self, gate, num):
        self.gate = gate
        self.F_S = num
        


global End_ps
End_ps = []         #끝 점들 모음.


class Start_P(Point):
    nextP = []
    line = []
    clk = 0


    def __init__(self, x, y):
        self.px = x
        self.py = y
        self.nextP = []
        self.line = []
        self.clk = 0
        self.linked_x = []
        self.linked_y = []
        self.b = canv.create_oval(self.px - 4, self.py - 4, self.px + 4, self.py + 4, fill="black")
        
        canv.tag_bind(self.b, '<B1-Motion>', self.line_drawing)
        canv.tag_bind(self.b, '<ButtonRelease-1>', self.line_end)
        canv.tag_bind(self.b, '<Button-3>', self.del_all_line_Ev)

    def del_b(self):
        canv.delete(self.b)
    
    def setRes(self, c):
        global End_ps
        self.res = c
        for i in self.nextP:
            if(type(i) == type(self)):
                i.setRes(c)
            elif(type(i) == int()):
                if(self.check_next_Real(i)):
                    End_ps[i].setRes(c)
                else:
                    self.del_void_link


    def setnextP(self, k):
        self.nextP.append(k)
        self.nextP[len(self.line)-1].setRes(self.res)

    def del_all_line(self):
        while(len(self.nextP) != 0):
            if(type(self.nextP[0]) == type(self)):
                self.nextP[0].del_all_line()
                self.nextP[0].del_b()
                c = self.nextP.pop(0)
                del c

            elif(type(self.nextP[0]) == int):
                global End_ps
                if(self.check_next_Real(self.nextP[0]) == True):
                    End_ps[self.nextP[0]].setRes(None)
                    self.del_void_link
                del(self.nextP[0])

        for i in range (len(self.line)):
            canv.delete(self.line[0])
            del self.line[0]


    def del_all_line_Ev(self, event):
        self.del_all_line()


    def line_drawing(self, event):
        if(self.clk == 1):
            canv.delete(self.line[-1])
            del self.line[-1]
        
        if(event.y <= self.py + 8 and event.y >= self.py - 8):   #가로선
            self.line.append(canv.create_line(self.px + 4, self.py, event.x, self.py, width = 5))
        elif(event.x <= self.px + 8 and event.x >= self.px - 8): #세로선
            self.line.append(canv.create_line(self.px, self.py + 4, self.px, event.y, width = 5))
        elif(abs(event.y) - self.py <= abs(event.x) - self.px): #-|
            self.line.append(canv.create_line(self.px + 4, self.py, event.x, self.py, event.x, event.y, width=5))
        elif(abs(event.y) - self.py >= abs(event.x) - self.px): #ㄱ/ㄴ
            self.line.append(canv.create_line(self.px, self.py + 4, self.px, event.y, event.x, event.y, width=5))

        self.clk = 1
        

    def line_end(self, event):
        global End_ps
        for k in range(len(End_ps)):
            i = End_ps[k]
            if(event.x <= i.px + 4 and event.x >= i.px -4 and event.y >=i.py - 4 and event.y <= i.py + 4):
                canv.delete(self.line[-1])
                del self.line[-1]
                if(i.res == None):
                    self.line.append(canv.create_line(self.px, self.py, self.px, i.py, i.px - 4, i.py, width=5))
                    self.nextP.append(k)
                    i.setRes(self.res)
                    self.linked_x.append(i.px)
                    self.linked_y.append(i.py)
                    self.clk = 0
                break
        if(self.clk == 1):
            if(event.y <= self.py + 8 and event.y >= self.py -8):
                self.nextP.append(Start_P(event.x, self.py))
            elif(event.x <= self.px + 8 and event.x >= self.px - 8): #세로선
                self.nextP.append(Start_P(self.px, event.y))
            else:
                self.nextP.append(Start_P(event.x, event.y))

            self.nextP[-1].setRes(self.res)
            self.clk = 0

    def del_void_link(self):
        global End_ps
        rec = []
        for k in range(len(self.linked_x)):
            clk = 0
            for i in End_ps:
                if(i.px == self.linked_x[k] and i.py == self.linked_y[k]):
                    break
                clk = 1
            if(clk == 1):
                rec.append(k)
        while(len(rec) != 0):
            del self.linked_x[rec[-1]]
            del self.linked_y[rec[-1]]
            del rec[-1]



    def check_next_Real(self, i):
        global End_ps
        for k in range(len(self.linked_x)):
            if(End_ps[i].px == self.linked_x[k] and End_ps[i].py == self.linked_y[k]):
                return True
        return False

    def del_void_link(self):
        global End_ps
        a = []
        b = []
        for z in self.nextP:
            if(type(z) == int()):
                a.append(z)

        for k in len(self.linked_x):
            clk = 0
            for i in a:
                if(End_ps[a].px == self.linked_x[i] and End_ps[a].py == self.linked_y[i]):
                    break
                clk = 1
            if(clk == 1):
                b.append(k)

        while(len(b) != 0):
            del self.linked_x[b[-1]]
            del self.linked_y[b[-1]]
            del b[-1]

'''
class gate:
    #px = float()
    #py = float()
    #res = str()                 
    #Outp = Start_P(None, None)  점의 중간 위치

    def __init__(self, x):          #gate_menu Button-1 시 생성. 드래그로 마우스 따라옴, release로 set
        self.loca = x               #놓인 gate 재클릭~드래그 시 이동 됨과 동시에 gate에 연결된 모든 선 삭제 및 Input 점들의 res를 None으로 초기화, gate의 res도 초기화
                                    #우클릭 시 아래 or 말풍선으로 식 gate의 res 값 보여줌

    def move(self, x):          # 게이트 이동 - 클릭후 이동시켜 main에 놓을때 사용
        self.loca = x           # 이동시 값 확인 -> 있다면 연결된 곳 가서 선 삭제 -> 본인 값 삭제 -> 

    #def linked(self, y):
    '''


class In2_gate:
    #Type = [And, Nand...]
    #x, y   위치
    #shape = 모형
    #sent   식
    #res    값
    #Input1, 2 = Point()

    def __init__(self, Type, x, y):
        self.Type = Type
        self.x = x
        self.y = y

        self.shape = Draw_gate(Type, x, y)

        if (Type == 'And' or 'Nand'):
            self.Input1 = Point(x - 15, y - 9)
            self.Input2 = Point(x - 15, y + 9)
            self.Output = Start_P(x + 28, y)
            self.Input1.set_gate(self, 1)
            self.Input2.set_gate(self, 2)

        elif(Type == 'Nor' or 'Ex_or' or 'Nor'):
            self.Input1 = Point(x - 25, y - 9)
            self.Input2 = Point(x - 25, y + 9)
            self.Output = Start_P(x + 23, y)
            self.Input1.set_gate(self, 1)
            self.Input2.set_gate(self, 2)

        canv.tag_bind(self.shape, '<B1-Motion>', self.moving)               #이동 -> 값 초기화, 선 삭제
        canv.tag_bind(self.shape, '<ButtonRelease-1>', self.make_gate)      #게이트 생성
        canv.tag_bind(self.shape, '<Button-3>', self.del_gate)              #삭제
        canv.tag_bind(self.shape, '<Button-1>', self.show_exp)              #식 출력

        def moving(self, event):
            #값 초기화
            #선 삭제
            for i in self.shape:
                canv.delete(i)
            self.shape = Draw_gate(self.Type, self,x, self,y)
            #점들 이동
            



    def setP(self, x, y):
        for i in self.shape:
            canv.delete(i)

        self.x = x
        self.y = y

        self.shape = Draw_gate(self.Type, self.x, self.y)


    def setPoints(self):
        if (self.Type == 'And' or 'Nand'):
            self.Input1 = Point(self.x - 15, self.y - 9)
            self.Input2 = Point(self.x - 15, self.y + 9)
            self.Output = Start_P(self.x + 28, self.y)
            self.Input1.set_gate(self, 1)
            self.Input2.set_gate(self, 2)

        elif(self.Type == 'Nor' or 'Ex_or' or 'Nor'):
            self.Input1 = Point(self.x - 25, self.y - 9)
            self.Input2 = Point(self.x - 25, self.y + 9)
            self.Output = Start_P(self.x + 23, self.y)
            self.Input1.set_gate(self, 1)
            self.Input2.set_gate(self, 2)

    def delPointshape(self):



        '''
        이동 -> 값 초기화
                전 / 후 붙은 선 삭제
        좌클릭 -> 식 출력
        우클릭 -> 삭제
        식으로 계산 하는 것 만들기.
        첫 출발 값은 전역으로 리스트 형식 저장
        '''










class AND_gate(In2_gate):

    def __init__(self, x, y):
        self.px = x
        self.py = y
        


class gate_menu:            # 오른쪽에 있을 게이트 생성 위한 모형
    listof_gate_type = ['Start', 'End', 'And', 'Nand', 'Or', 'Nor', 'Not', 'Ex-Or']
    px = float()
    py = float()
    #gate_type에 따라 다른 모양의 게이트
    #클릭시 각 점 없이 gate 모양만 생성, 마우스 따라가게 함. 이후 button release 시 그 자리에 gate 생성




a = Start_P(100, 100)


b = Point(500, 500)
End_ps.append(b)






win.mainloop()
