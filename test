from asyncio.windows_events import *
from asyncio.windows_events import NULL
from tkinter import *

global win
win = Tk()

win.title("Test")
win.option_add("*Fonts", "맑은고딕 25")
win.geometry("1280x800")

global canv
canv = Canvas(win, width = 1280, height = 800, background = 'white')
canv.pack(padx = 0, pady = 0)


class Point:            #점의 위치
    px = float()
    py = float()
    res = str()
    b = int()

    def __init__(self, x, y):
        self.px = x
        self.py = y
        self.res = None
        self.b = canv.create_oval(self.px - 4, self.py - 4, self.px + 4, self.py + 4, fill="black")

    def setPoint(self, x, y):
        self.px = x
        self.py = y
        canv.delete(self.b)
        self.b = canv.create_oval(self.px - 4, self.py - 4, self.px + 4, self.py + 4, fill="black")


    def setRes(self, c):
        self.res = c
        


global End_ps
End_ps = []         #끝 점들 모음.


class Start_P(Point):
    nextP = []
    line = []
    clk = 0


    def __init__(self, x, y):
        self.px = x
        self.py = y
        self.nextP = []
        self.line = []
        self.clk = 0
        self.b = canv.create_oval(self.px - 4, self.py - 4, self.px + 4, self.py + 4, fill="black")
        
        canv.tag_bind(self.b, '<B1-Motion>', self.line_drawing)
        canv.tag_bind(self.b, '<ButtonRelease-1>', self.line_end)
        canv.tag_bind(self.b, '<Button-3>', self.del_all_line_Ev)

    def del_b(self):
        canv.delete(self.b)



    def setnextP(self, k):
        self.nextP.append(k)
        self.nextP[len(self.line)-1].setRes(self.res)

    def del_all_line(self):
        while(len(self.nextP) != 0):
            if(type(self.nextP[0]) == type(self)):
                self.nextP[0].del_all_line()
                self.nextP[0].del_b()
                c = self.nextP.pop(0)
                del c

            elif(type(self.nextP[0]) == int):
                global End_ps
                End_ps[self.nextP[0]].setRes(None)
                del(self.nextP[0])

        for i in range (len(self.line)):
            canv.delete(self.line[0])
            del self.line[0]


    def del_all_line_Ev(self, event):       #대체
        while(len(self.nextP) != 0):
            if(type(self.nextP[0]) == type(self)):
                self.nextP[0].del_all_line()
                self.nextP[0].del_b()
                c = self.nextP.pop(0)
                del c

            elif(type(self.nextP[0]) == int):
                global End_ps
                End_ps[self.nextP[0]].setRes(None)
                del(self.nextP[0])

        for i in range (len(self.line)):
            canv.delete(self.line[0])
            del self.line[0]


    def line_drawing(self, event):
        if(self.clk == 1):
            canv.delete(self.line[-1])
            del self.line[-1]
        
        if(event.y <= self.py + 1 and event.y >= self.py -1):
            self.line.append(canv.create_line(self.px + 4, self.py, event.x, self.py, width = 5))
        elif(event.x <= self.px + 1 and event.x >= self.px -1):
            self.line.append(canv.create_line(self.px, self.py + 4, self.px, event.y, width = 5))
        elif(abs(event.y) - self.py <= abs(event.x) - self.px):
            self.line.append(canv.create_line(self.px + 4, self.py, event.x, self.py, event.x, event.y, width=5))
        elif(abs(event.y) - self.py >= abs(event.x) - self.px):
            self.line.append(canv.create_line(self.px, self.py + 4, self.px, event.y, event.x, event.y, width=5))

        self.clk = 1
        

    def line_end(self, event):
        global End_ps
        for k in range(len(End_ps)):
            i = End_ps[k]
            if(event.x <= i.px + 4 and event.x >= i.px -4 and event.y >=i.py - 4 and event.y <= i.py + 4):
                canv.delete(self.line[-1])
                del self.line[-1]
                if(i.res == None):
                    self.line.append(canv.create_line(self.px, self.py, self.px, i.py, i.px - 4, i.py, width=5))
                    self.nextP.append(k)
                    i.setRes(self.res)
                    self.clk = 0
                break
        if(self.clk == 1):
            self.nextP.append(Start_P(event.x, event.y))
            self.nextP[-1].setRes(self.res)
            self.clk = 0
     

class gate:
    #px = float()
    #py = float()
    #res = str()                 
    #Outp = Start_P(None, None)  점의 중간 위치

    def __init__(self, x):          #gate_menu Button-1 시 생성. 드래그로 마우스 따라옴, release로 set
        self.loca = x               #놓인 gate 재클릭~드래그 시 이동 됨과 동시에 gate에 연결된 모든 선 삭제 및 Input 점들의 res를 None으로 초기화, gate의 res도 초기화
                                    #우클릭 시 아래 or 말풍선으로 식 gate의 res 값 보여줌

    def move(self, x):          # 게이트 이동 - 클릭후 이동시켜 main에 놓을때 사용
        self.loca = x

    #def linked(self, y):





class AND_gate(gate):

    def __init__(self, x, y):
        self.px = x
        self.py = y
        


class gate_menu:            # 오른쪽에 있을 게이트 생성 위한 모형
    gate_type = ['Start', 'End', 'And', 'Nand', 'Or', 'Nor', 'Not', 'Ex-Or']
    px = float()
    py = float()
    #gate_type에 따라 다른 모양의 게이트
    #클릭시 각 점 없이 gate 모양만 생성, 마우스 따라가게 함. 이후 button release 시 그 자리에 gate 생성




a = Start_P(100, 100)


b = Point(500, 500)
End_ps.append(b)






win.mainloop()
